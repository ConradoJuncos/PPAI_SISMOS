<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java" />
              <option name="updatedContent" value="package com.ppai.sismos;&#10;&#10;import com.ppai.sismos.controlador.SismoController;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.staticfiles.Location;&#10;&#10;/**&#10; * Clase principal que inicia el servidor HTTP&#10; */&#10;public class Main {&#10;    &#10;    private static final int PORT = 8080;&#10;    &#10;    public static void main(String[] args) {&#10;        // Crear el servidor Javalin&#10;        Javalin app = Javalin.create(config -&gt; {&#10;            // Configurar CORS para permitir conexiones desde el frontend de escritorio&#10;            config.plugins.enableCors(cors -&gt; {&#10;                cors.add(it -&gt; {&#10;                    it.anyHost(); // Permite cualquier origen&#10;                    it.allowCredentials = false;&#10;                });&#10;            });&#10;            &#10;            // Configurar logging&#10;            config.requestLogger.http((ctx, ms) -&gt; {&#10;                System.out.println(ctx.method() + &quot; &quot; + ctx.path() + &quot; - &quot; + ctx.status() + &quot; (&quot; + ms + &quot;ms)&quot;);&#10;            });&#10;        });&#10;        &#10;        // Registrar rutas del controlador&#10;        SismoController sismoController = new SismoController();&#10;        sismoController.registrarRutas(app);&#10;        &#10;        // Ruta de health check&#10;        app.get(&quot;/&quot;, ctx -&gt; ctx.result(&quot;API de Sismos - Backend funcionando correctamente&quot;));&#10;        &#10;        app.get(&quot;/health&quot;, ctx -&gt; ctx.json(java.util.Map.of(&#10;                &quot;status&quot;, &quot;UP&quot;,&#10;                &quot;timestamp&quot;, java.time.LocalDateTime.now().toString()&#10;        )));&#10;        &#10;        // Iniciar el servidor&#10;        app.start(PORT);&#10;        &#10;        System.out.println(&quot;╔═══════════════════════════════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║   Backend de Sistema de Sismos - Iniciado            ║&quot;);&#10;        System.out.println(&quot;║   Puerto: &quot; + PORT + &quot;                                       ║&quot;);&#10;        System.out.println(&quot;║   URL: http://localhost:&quot; + PORT + &quot;                       ║&quot;);&#10;        System.out.println(&quot;║   CORS: Habilitado                                    ║&quot;);&#10;        System.out.println(&quot;║   Base de datos: SQLite (sismos.db)                   ║&quot;);&#10;        System.out.println(&quot;╚═══════════════════════════════════════════════════════╝&quot;);&#10;        System.out.println(&quot;\nPresiona Ctrl+C para detener el servidor\n&quot;);&#10;        &#10;        // Hook para cerrar la base de datos al detener el servidor&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;\nCerrando servidor...&quot;);&#10;            app.stop();&#10;            com.ppai.sismos.datos.DatabaseConnection.getInstance().close();&#10;            System.out.println(&quot;Servidor cerrado correctamente&quot;);&#10;        }));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java" />
              <option name="updatedContent" value="package com.ppai.sismos.controlador;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.GsonBuilder;&#10;import com.google.gson.JsonDeserializer;&#10;import com.google.gson.JsonPrimitive;&#10;import com.google.gson.JsonSerializer;&#10;import com.ppai.sismos.entidad.Sismo;&#10;import com.ppai.sismos.gestor.GestorSismos;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.Context;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Controlador REST que expone los endpoints de la API&#10; * y delega las operaciones al Gestor&#10; */&#10;public class SismoController {&#10;    &#10;    private final GestorSismos gestor;&#10;    private final Gson gson;&#10;    &#10;    public SismoController() {&#10;        this.gestor = GestorSismos.getInstance();&#10;        &#10;        // Configurar Gson para manejar LocalDateTime&#10;        GsonBuilder gsonBuilder = new GsonBuilder();&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonSerializer&lt;LocalDateTime&gt;) (src, typeOfSrc, context) -&gt;&#10;                        new JsonPrimitive(src.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)));&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonDeserializer&lt;LocalDateTime&gt;) (json, typeOfT, context) -&gt;&#10;                        LocalDateTime.parse(json.getAsString(), DateTimeFormatter.ISO_LOCAL_DATE_TIME));&#10;        this.gson = gsonBuilder.create();&#10;    }&#10;    &#10;    public void registrarRutas(Javalin app) {&#10;        // Obtener todos los sismos&#10;        app.get(&quot;/api/sismos&quot;, this::obtenerTodos);&#10;        &#10;        // Obtener un sismo por ID&#10;        app.get(&quot;/api/sismos/{id}&quot;, this::obtenerPorId);&#10;        &#10;        // Crear un nuevo sismo&#10;        app.post(&quot;/api/sismos&quot;, this::crear);&#10;        &#10;        // Actualizar un sismo&#10;        app.put(&quot;/api/sismos/{id}&quot;, this::actualizar);&#10;        &#10;        // Eliminar un sismo&#10;        app.delete(&quot;/api/sismos/{id}&quot;, this::eliminar);&#10;        &#10;        // Buscar por magnitud&#10;        app.get(&quot;/api/sismos/buscar/magnitud/{magnitud}&quot;, this::buscarPorMagnitud);&#10;        &#10;        // Buscar por ubicación&#10;        app.get(&quot;/api/sismos/buscar/ubicacion/{ubicacion}&quot;, this::buscarPorUbicacion);&#10;        &#10;        // Obtener estadísticas&#10;        app.get(&quot;/api/sismos/estadisticas&quot;, this::obtenerEstadisticas);&#10;    }&#10;    &#10;    private void obtenerTodos(Context ctx) {&#10;        try {&#10;            List&lt;Sismo&gt; sismos = gestor.obtenerTodosLosSismos();&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerPorId(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Optional&lt;Sismo&gt; sismo = gestor.buscarSismoPorId(id);&#10;            &#10;            if (sismo.isPresent()) {&#10;                ctx.json(sismo.get());&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void crear(Context ctx) {&#10;        try {&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo nuevoSismo = gestor.registrarNuevoSismo(&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.status(201).json(nuevoSismo);&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void actualizar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo sismoActualizado = gestor.actualizarSismo(&#10;                    id,&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.json(sismoActualizado);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void eliminar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            &#10;            boolean eliminado = gestor.eliminarSismo(id);&#10;            &#10;            if (eliminado) {&#10;                ctx.status(204);&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorMagnitud(Context ctx) {&#10;        try {&#10;            Double magnitud = Double.parseDouble(ctx.pathParam(&quot;magnitud&quot;));&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorMagnitudMinima(magnitud);&#10;            ctx.json(sismos);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;Magnitud inválida&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorUbicacion(Context ctx) {&#10;        try {&#10;            String ubicacion = ctx.pathParam(&quot;ubicacion&quot;);&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorUbicacion(ubicacion);&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerEstadisticas(Context ctx) {&#10;        try {&#10;            GestorSismos.EstadisticasSismos estadisticas = gestor.calcularEstadisticas();&#10;            ctx.json(estadisticas);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java" />
              <option name="updatedContent" value="package com.ppai.sismos.datos;&#10;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class SismoDAO {&#10;    &#10;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;&#10;    private final DatabaseConnection dbConnection;&#10;    &#10;    public SismoDAO() {&#10;        this.dbConnection = DatabaseConnection.getInstance();&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; obtenerTodos() {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (Statement stmt = dbConnection.getConnection().createStatement();&#10;             ResultSet rs = stmt.executeQuery(sql)) {&#10;            &#10;            while (rs.next()) {&#10;                sismos.add(mapResultSetToSismo(rs));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismos&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public Optional&lt;Sismo&gt; obtenerPorId(Long id) {&#10;        String sql = &quot;SELECT * FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismo por ID&quot;, e);&#10;        }&#10;        &#10;        return Optional.empty();&#10;    }&#10;    &#10;    public Sismo guardar(Sismo sismo) {&#10;        String sql = &quot;INSERT INTO sismos (ubicacion, magnitud, profundidad, fecha_hora, descripcion) VALUES (?, ?, ?, ?, ?)&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se pudo crear el sismo&quot;);&#10;            }&#10;            &#10;            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    sismo.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al guardar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public Sismo actualizar(Sismo sismo) {&#10;        String sql = &quot;UPDATE sismos SET ubicacion = ?, magnitud = ?, profundidad = ?, fecha_hora = ?, descripcion = ? WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            pstmt.setLong(6, sismo.getId());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se encontró el sismo con ID: &quot; + sismo.getId());&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al actualizar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public boolean eliminar(Long id) {&#10;        String sql = &quot;DELETE FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            return affectedRows &gt; 0;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al eliminar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorMagnitud(Double magnitudMinima) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE magnitud &gt;= ? ORDER BY magnitud DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setDouble(1, magnitudMinima);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por magnitud&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorUbicacion(String ubicacion) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE LOWER(ubicacion) LIKE LOWER(?) ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, &quot;%&quot; + ubicacion + &quot;%&quot;);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por ubicación&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    private Sismo mapResultSetToSismo(ResultSet rs) throws SQLException {&#10;        Long id = rs.getLong(&quot;id&quot;);&#10;        String ubicacion = rs.getString(&quot;ubicacion&quot;);&#10;        Double magnitud = rs.getDouble(&quot;magnitud&quot;);&#10;        Double profundidad = rs.getDouble(&quot;profundidad&quot;);&#10;        LocalDateTime fechaHora = LocalDateTime.parse(rs.getString(&quot;fecha_hora&quot;), FORMATTER);&#10;        String descripcion = rs.getString(&quot;descripcion&quot;);&#10;        &#10;        return new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java" />
              <option name="updatedContent" value="package com.ppai.sismos.gestor;&#10;&#10;import com.ppai.sismos.datos.SismoDAO;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Gestor que maneja las colaboraciones entre objetos del sistema.&#10; * Esta clase centraliza la lógica de negocio y coordina las operaciones&#10; * entre las entidades y el acceso a datos.&#10; */&#10;public class GestorSismos {&#10;    &#10;    private static GestorSismos instance;&#10;    private final SismoDAO sismoDAO;&#10;    &#10;    private GestorSismos() {&#10;        this.sismoDAO = new SismoDAO();&#10;    }&#10;    &#10;    public static GestorSismos getInstance() {&#10;        if (instance == null) {&#10;            synchronized (GestorSismos.class) {&#10;                if (instance == null) {&#10;                    instance = new GestorSismos();&#10;                }&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;    &#10;    /**&#10;     * Obtiene todos los sismos registrados&#10;     */&#10;    public List&lt;Sismo&gt; obtenerTodosLosSismos() {&#10;        return sismoDAO.obtenerTodos();&#10;    }&#10;    &#10;    /**&#10;     * Busca un sismo por su ID&#10;     */&#10;    public Optional&lt;Sismo&gt; buscarSismoPorId(Long id) {&#10;        return sismoDAO.obtenerPorId(id);&#10;    }&#10;    &#10;    /**&#10;     * Registra un nuevo sismo en el sistema&#10;     * Valida los datos antes de guardar&#10;     */&#10;    public Sismo registrarNuevoSismo(String ubicacion, Double magnitud, Double profundidad, &#10;                                     LocalDateTime fechaHora, String descripcion) {&#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear la entidad&#10;        Sismo nuevoSismo = new Sismo(ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Guardar en la base de datos&#10;        return sismoDAO.guardar(nuevoSismo);&#10;    }&#10;    &#10;    /**&#10;     * Actualiza un sismo existente&#10;     */&#10;    public Sismo actualizarSismo(Long id, String ubicacion, Double magnitud, Double profundidad,&#10;                                 LocalDateTime fechaHora, String descripcion) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear entidad actualizada&#10;        Sismo sismoActualizado = new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Actualizar en la base de datos&#10;        return sismoDAO.actualizar(sismoActualizado);&#10;    }&#10;    &#10;    /**&#10;     * Elimina un sismo del sistema&#10;     */&#10;    public boolean eliminarSismo(Long id) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        return sismoDAO.eliminar(id);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos con magnitud mayor o igual a la especificada&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorMagnitudMinima(Double magnitudMinima) {&#10;        if (magnitudMinima &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser negativa&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorMagnitud(magnitudMinima);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos por ubicación (búsqueda parcial)&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorUbicacion(String ubicacion) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación no puede estar vacía&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorUbicacion(ubicacion);&#10;    }&#10;    &#10;    /**&#10;     * Obtiene sismos recientes (últimos registrados)&#10;     */&#10;    public List&lt;Sismo&gt; obtenerSismosRecientes(int cantidad) {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.size() &lt;= cantidad) {&#10;            return todosLosSismos;&#10;        }&#10;        &#10;        return todosLosSismos.subList(0, cantidad);&#10;    }&#10;    &#10;    /**&#10;     * Calcula estadísticas de los sismos&#10;     */&#10;    public EstadisticasSismos calcularEstadisticas() {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.isEmpty()) {&#10;            return new EstadisticasSismos(0, 0.0, 0.0, 0.0);&#10;        }&#10;        &#10;        double magnitudMaxima = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .max()&#10;                .orElse(0.0);&#10;        &#10;        double magnitudPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        double profundidadPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getProfundidad)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        return new EstadisticasSismos(&#10;                todosLosSismos.size(),&#10;                magnitudMaxima,&#10;                magnitudPromedio,&#10;                profundidadPromedio&#10;        );&#10;    }&#10;    &#10;    // Validaciones privadas&#10;    private void validarDatosSismo(String ubicacion, Double magnitud, Double profundidad, LocalDateTime fechaHora) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación es obligatoria&quot;);&#10;        }&#10;        &#10;        if (magnitud == null || magnitud &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (magnitud &gt; 10) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser mayor a 10&quot;);&#10;        }&#10;        &#10;        if (profundidad == null || profundidad &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La profundidad debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (fechaHora == null) {&#10;            throw new IllegalArgumentException(&quot;La fecha y hora son obligatorias&quot;);&#10;        }&#10;        &#10;        if (fechaHora.isAfter(LocalDateTime.now())) {&#10;            throw new IllegalArgumentException(&quot;La fecha no puede ser futura&quot;);&#10;        }&#10;    }&#10;    &#10;    // Clase interna para estadísticas&#10;    public static class EstadisticasSismos {&#10;        private final int totalSismos;&#10;        private final double magnitudMaxima;&#10;        private final double magnitudPromedio;&#10;        private final double profundidadPromedio;&#10;        &#10;        public EstadisticasSismos(int totalSismos, double magnitudMaxima, &#10;                                 double magnitudPromedio, double profundidadPromedio) {&#10;            this.totalSismos = totalSismos;&#10;            this.magnitudMaxima = magnitudMaxima;&#10;            this.magnitudPromedio = magnitudPromedio;&#10;            this.profundidadPromedio = profundidadPromedio;&#10;        }&#10;        &#10;        public int getTotalSismos() { return totalSismos; }&#10;        public double getMagnitudMaxima() { return magnitudMaxima; }&#10;        public double getMagnitudPromedio() { return magnitudPromedio; }&#10;        public double getProfundidadPromedio() { return profundidadPromedio; }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sistema-red-sismica/src/main/java/com/ppai/app/dao/CambioEstadoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sistema-red-sismica/src/main/java/com/ppai/app/dao/CambioEstadoDAO.java" />
              <option name="originalContent" value="package com.ppai.app.dao;&#10;&#10;import com.ppai.app.datos.DatabaseConnection;&#10;import com.ppai.app.entidad.*;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;public class CambioEstadoDAO {&#10;&#10;    private final EstadoDAO estadoDAO = new EstadoDAO();&#10;    private final EmpleadoDAO empleadoDAO = new EmpleadoDAO();&#10;    private final MotivoFueraServicioDAO motivoFueraServicioDAO = new MotivoFueraServicioDAO();&#10;&#10;    /* --------------------------------------------------------------&#10;       INSERT – guarda datos principales + relaciones. &#10;       -------------------------------------------------------------- */&#10;    public void insert(CambioEstado ce) throws SQLException {&#10;        // SQL corregido: usa la clave natural compuesta (ambitoEstado, nombreEstado)&#10;        String sql = &quot;INSERT INTO CambioEstado (fechaHoraInicio, fechaHoraFin, ambitoEstado, nombreEstado, idResponsableInspeccion, idEventoSismico) &quot; +&#10;                     &quot;VALUES (?, ?, ?, ?, ?, ?)&quot;;&#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;&#10;            ps.setObject(1, ce.getFechaHoraInicio());&#10;            ps.setObject(2, ce.getFechaHoraFin());&#10;            &#10;            // Usamos la clave compuesta del Estado&#10;            ps.setString(3, ce.getEstado().getAmbito());&#10;            ps.setString(4, ce.getEstado().getNombreEstado());&#10;            &#10;            // idResponsableInspeccion puede ser NULL si no aplica&#10;            ps.setObject(5, ce.getResponsableInspeccion() != null ? ce.getResponsableInspeccion().getIdEmpleado() : null);&#10;            &#10;            // idEventoSismico puede ser NULL si no aplica&#10;            ps.setObject(6, ce.getIdEventoSismico());&#10;&#10;            ps.executeUpdate();&#10;&#10;            try (ResultSet rs = ps.getGeneratedKeys()) {&#10;                if (rs.next()) {&#10;                    long idCambio = rs.getLong(1);&#10;                    ce.setIdCambioEstado(idCambio);&#10;                    &#10;                    // Persistir relación N:N con MotivoFueraServicio&#10;                    if (ce.getMotivoFueraServicio() != null &amp;&amp; !ce.getMotivoFueraServicio().isEmpty()) {&#10;                        insertMotivos(conn, idCambio, ce.getMotivoFueraServicio());&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /* --------------------------------------------------------------&#10;       UPDATE – actualiza el cambio de estado.&#10;       -------------------------------------------------------------- */&#10;    public void update(CambioEstado ce) throws SQLException {&#10;        String sql = &quot;UPDATE CambioEstado SET fechaHoraInicio = ?, fechaHoraFin = ?, ambitoEstado = ?, nombreEstado = ?, idResponsableInspeccion = ?, idEventoSismico = ? WHERE idCambioEstado = ?&quot;;&#10;        &#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setObject(1, ce.getFechaHoraInicio());&#10;            ps.setObject(2, ce.getFechaHoraFin());&#10;            &#10;            // Usamos la clave compuesta del Estado&#10;            ps.setString(3, ce.getEstado().getAmbito());&#10;            ps.setString(4, ce.getEstado().getNombreEstado());&#10;            &#10;            ps.setObject(5, ce.getResponsableInspeccion() != null ? ce.getResponsableInspeccion().getIdEmpleado() : null);&#10;            ps.setLong  (6, ce.getIdCambioEstado());&#10;&#10;            ps.executeUpdate();&#10;            &#10;            // Actualizar relación N:N con MotivoFueraServicio&#10;            deleteMotivos(conn, ce.getIdCambioEstado());&#10;            if (ce.getMotivoFueraServicio() != null &amp;&amp; !ce.getMotivoFueraServicio().isEmpty()) {&#10;                insertMotivos(conn, ce.getIdCambioEstado(), ce.getMotivoFueraServicio());&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* --------------------------------------------------------------&#10;       DELETE – elimina el cambio de estado y sus relaciones&#10;       -------------------------------------------------------------- */&#10;    public void delete(long idCambioEstado) throws SQLException {&#10;        try (Connection conn = DatabaseConnection.getConnection()) {&#10;            // 1. Eliminar la relación N:N con MotivoFueraServicio&#10;            deleteMotivos(conn, idCambioEstado);&#10;            &#10;            // 2. Eliminar el registro principal&#10;            String sql = &quot;DELETE FROM CambioEstado WHERE idCambioEstado = ?&quot;;&#10;            try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;                ps.setLong(1, idCambioEstado);&#10;                ps.executeUpdate();&#10;            }&#10;        }&#10;    }&#10;&#10;    /* --------------------------------------------------------------&#10;       FIND BY ID – carga todo&#10;       -------------------------------------------------------------- */&#10;    public CambioEstado findById(long idCambioEstado) throws SQLException {&#10;        String sql = &quot;SELECT * FROM CambioEstado WHERE idCambioEstado = ?&quot;;&#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setLong(1, idCambioEstado);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return mapResultSetToCambioEstado(rs, conn);&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // --- NUEVO MÉTODO SOLICITADO ---&#10;    /* --------------------------------------------------------------&#10;       FIND BY SISMOGRAFO ID – carga todos los cambios de estado para un sismógrafo.&#10;       Se asume que la relación es 1:N (Sismografo:CambioEstado) gestionada por una tabla intermedia.&#10;       -------------------------------------------------------------- */&#10;    public List&lt;CambioEstado&gt; findBySismografoId(Connection conn, long idSismografo) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT ce.* FROM CambioEstado ce&#10;            JOIN Sismografo_CambioEstado ces ON ce.idCambioEstado = ces.idCambioEstado&#10;            WHERE ces.identificadorSismografo = ?&#10;            ORDER BY ce.fechaHoraInicio ASC&#10;            &quot;&quot;&quot;;&#10;        List&lt;CambioEstado&gt; cambios = new ArrayList&lt;&gt;();&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idSismografo);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    // Reutilizamos el mapeador, pasándole la conexión activa&#10;                    cambios.add(mapResultSetToCambioEstado(rs, conn));&#10;                }&#10;            }&#10;        }&#10;        return cambios;&#10;    }&#10;    &#10;    /* --------------------------------------------------------------&#10;       FIND BY EVENTO SISMICO ID – carga todos los cambios de estado para un evento&#10;       -------------------------------------------------------------- */&#10;    public List&lt;CambioEstado&gt; findByEventoSismicoId(Connection conn, long idEventoSismico) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT ce.* FROM CambioEstado ce&#10;            JOIN EventoSismico_CambioEstado ece ON ce.idCambioEstado = ece.idCambioEstado&#10;            WHERE ece.idEventoSismico = ?&#10;            ORDER BY ce.fechaHoraInicio ASC&#10;            &quot;&quot;&quot;;&#10;        List&lt;CambioEstado&gt; cambios = new ArrayList&lt;&gt;();&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idEventoSismico);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    cambios.add(mapResultSetToCambioEstado(rs, conn));&#10;                }&#10;            }&#10;        }&#10;        return cambios;&#10;    }&#10;    &#10;    // ==============================================================&#10;    // MÉTODOS AUXILIARES&#10;    // ==============================================================&#10;&#10;    private CambioEstado mapResultSetToCambioEstado(ResultSet rs, Connection conn) throws SQLException {&#10;        CambioEstado ce = new CambioEstado();&#10;&#10;        ce.setIdCambioEstado(rs.getLong(&quot;idCambioEstado&quot;));&#10;        ce.setFechaHoraInicio(getLocalDateTime(rs, &quot;fechaHoraInicio&quot;));&#10;        ce.setFechaHoraFin(getLocalDateTime(rs, &quot;fechaHoraFin&quot;));&#10;&#10;        // Cargar Estado usando la CLAVE COMPUESTA&#10;        String ambito = rs.getString(&quot;ambitoEstado&quot;);&#10;        String nombreEstado = rs.getString(&quot;nombreEstado&quot;);&#10;        Estado estado = estadoDAO.findByAmbitoAndNombre(ambito, nombreEstado);&#10;        ce.setEstado(estado);&#10;&#10;        // Cargar Empleado&#10;        Long idEmpleado = rs.getObject(&quot;idResponsableInspeccion&quot;, Long.class);&#10;        Empleado empleado = idEmpleado != null ? empleadoDAO.findById(idEmpleado) : null;&#10;        ce.setResponsableInspeccion(empleado);&#10;        &#10;        // Cargar idEventoSismico&#10;        Long idEventoSismico = rs.getObject(&quot;idEventoSismico&quot;, Long.class);&#10;        ce.setIdEventoSismico(idEventoSismico);&#10;&#10;        // Cargar motivos fuera de servicio&#10;        List&lt;MotivoFueraServicio&gt; motivos = findMotivosByCambioEstado(conn, ce.getIdCambioEstado());&#10;        ce.setMotivoFueraServicio(motivos);&#10;&#10;        return ce;&#10;    }&#10;&#10;    private LocalDateTime getLocalDateTime(ResultSet rs, String column) throws SQLException {&#10;        Timestamp ts = rs.getTimestamp(column);&#10;        return ts != null ? ts.toLocalDateTime() : null;&#10;    }&#10;&#10;    // ==============================================================&#10;    // MÉTODOS AUXILIARES PARA RELACIÓN N:N CON MotivoFueraServicio&#10;    // ==============================================================&#10;    &#10;    private void insertMotivos(Connection conn, long idCambioEstado, List&lt;MotivoFueraServicio&gt; motivos) throws SQLException {&#10;        String sql = &quot;INSERT INTO CambioEstado_MotivoFueraServicio (idCambioEstado, idMotivoFueraServicio) VALUES (?, ?)&quot;;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            for (MotivoFueraServicio mfs : motivos) {&#10;                ps.setLong(1, idCambioEstado);&#10;                ps.setLong(2, mfs.getIdMotivoFueraServicio());&#10;                ps.addBatch();&#10;            }&#10;            ps.executeBatch();&#10;        }&#10;    }&#10;&#10;    private void deleteMotivos(Connection conn, long idCambioEstado) throws SQLException {&#10;        String sql = &quot;DELETE FROM CambioEstado_MotivoFueraServicio WHERE idCambioEstado = ?&quot;;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idCambioEstado);&#10;            ps.executeUpdate();&#10;        }&#10;    }&#10;    &#10;    private List&lt;MotivoFueraServicio&gt; findMotivosByCambioEstado(Connection conn, long idCambioEstado) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT mfs.idMotivoFueraServicio FROM MotivoFueraServicio mfs&#10;            JOIN CambioEstado_MotivoFueraServicio cemfs ON mfs.idMotivoFueraServicio = cemfs.idMotivoFueraServicio&#10;            WHERE cemfs.idCambioEstado = ?&#10;            &quot;&quot;&quot;;&#10;        List&lt;MotivoFueraServicio&gt; motivos = new ArrayList&lt;&gt;();&#10;        &#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idCambioEstado);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    long idMotivo = rs.getLong(&quot;idMotivoFueraServicio&quot;);&#10;                    MotivoFueraServicio mfs = motivoFueraServicioDAO.findById(idMotivo); &#10;                    if (mfs != null) {&#10;                        motivos.add(mfs);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return motivos;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ppai.app.dao;&#10;&#10;import com.ppai.app.datos.DatabaseConnection;&#10;import com.ppai.app.entidad.*;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;public class CambioEstadoDAO {&#10;&#10;    private final EstadoDAO estadoDAO = new EstadoDAO();&#10;    private final EmpleadoDAO empleadoDAO = new EmpleadoDAO();&#10;    private final MotivoFueraServicioDAO motivoFueraServicioDAO = new MotivoFueraServicioDAO();&#10;&#10;    /* --------------------------------------------------------------&#10;       INSERT – guarda datos principales + relaciones. &#10;       -------------------------------------------------------------- */&#10;    public void insert(CambioEstado ce) throws SQLException {&#10;        // SQL corregido: usa la clave natural compuesta (ambitoEstado, nombreEstado)&#10;        String sql = &quot;INSERT INTO CambioEstado (fechaHoraInicio, fechaHoraFin, ambitoEstado, nombreEstado, idResponsableInspeccion, idEventoSismico) &quot; +&#10;                     &quot;VALUES (?, ?, ?, ?, ?, ?)&quot;;&#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;&#10;            ps.setObject(1, ce.getFechaHoraInicio());&#10;            ps.setObject(2, ce.getFechaHoraFin());&#10;            &#10;            // Usamos la clave compuesta del Estado&#10;            ps.setString(3, ce.getEstado().getAmbito());&#10;            ps.setString(4, ce.getEstado().getNombreEstado());&#10;            &#10;            // idResponsableInspeccion puede ser NULL si no aplica&#10;            ps.setObject(5, ce.getResponsableInspeccion() != null ? ce.getResponsableInspeccion().getIdEmpleado() : null);&#10;            &#10;            // idEventoSismico puede ser NULL si no aplica&#10;            ps.setObject(6, ce.getIdEventoSismico());&#10;&#10;            ps.executeUpdate();&#10;&#10;            try (ResultSet rs = ps.getGeneratedKeys()) {&#10;                if (rs.next()) {&#10;                    long idCambio = rs.getLong(1);&#10;                    ce.setIdCambioEstado(idCambio);&#10;                    &#10;                    // Persistir relación N:N con MotivoFueraServicio&#10;                    if (ce.getMotivoFueraServicio() != null &amp;&amp; !ce.getMotivoFueraServicio().isEmpty()) {&#10;                        insertMotivos(conn, idCambio, ce.getMotivoFueraServicio());&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /* --------------------------------------------------------------&#10;       UPDATE – actualiza el cambio de estado.&#10;       -------------------------------------------------------------- */&#10;    public void update(CambioEstado ce) throws SQLException {&#10;        String sql = &quot;UPDATE CambioEstado SET fechaHoraInicio = ?, fechaHoraFin = ?, ambitoEstado = ?, nombreEstado = ?, idResponsableInspeccion = ?, idEventoSismico = ? WHERE idCambioEstado = ?&quot;;&#10;        &#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setObject(1, ce.getFechaHoraInicio());&#10;            ps.setObject(2, ce.getFechaHoraFin());&#10;            &#10;            // Usamos la clave compuesta del Estado&#10;            ps.setString(3, ce.getEstado().getAmbito());&#10;            ps.setString(4, ce.getEstado().getNombreEstado());&#10;            &#10;            ps.setObject(5, ce.getResponsableInspeccion() != null ? ce.getResponsableInspeccion().getIdEmpleado() : null);&#10;            ps.setLong  (6, ce.getIdCambioEstado());&#10;&#10;            ps.executeUpdate();&#10;            &#10;            // Actualizar relación N:N con MotivoFueraServicio&#10;            deleteMotivos(conn, ce.getIdCambioEstado());&#10;            if (ce.getMotivoFueraServicio() != null &amp;&amp; !ce.getMotivoFueraServicio().isEmpty()) {&#10;                insertMotivos(conn, ce.getIdCambioEstado(), ce.getMotivoFueraServicio());&#10;            }&#10;        }&#10;    }&#10;    &#10;    /* --------------------------------------------------------------&#10;       DELETE – elimina el cambio de estado y sus relaciones&#10;       -------------------------------------------------------------- */&#10;    public void delete(long idCambioEstado) throws SQLException {&#10;        try (Connection conn = DatabaseConnection.getConnection()) {&#10;            // 1. Eliminar la relación N:N con MotivoFueraServicio&#10;            deleteMotivos(conn, idCambioEstado);&#10;            &#10;            // 2. Eliminar el registro principal&#10;            String sql = &quot;DELETE FROM CambioEstado WHERE idCambioEstado = ?&quot;;&#10;            try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;                ps.setLong(1, idCambioEstado);&#10;                ps.executeUpdate();&#10;            }&#10;        }&#10;    }&#10;&#10;    /* --------------------------------------------------------------&#10;       FIND BY ID – carga todo&#10;       -------------------------------------------------------------- */&#10;    public CambioEstado findById(long idCambioEstado) throws SQLException {&#10;        String sql = &quot;SELECT * FROM CambioEstado WHERE idCambioEstado = ?&quot;;&#10;        try (Connection conn = DatabaseConnection.getConnection();&#10;             PreparedStatement ps = conn.prepareStatement(sql)) {&#10;&#10;            ps.setLong(1, idCambioEstado);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return mapResultSetToCambioEstado(rs, conn);&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    // --- NUEVO MÉTODO SOLICITADO ---&#10;    /* --------------------------------------------------------------&#10;       FIND BY SISMOGRAFO ID – carga todos los cambios de estado para un sismógrafo.&#10;       Se asume que la relación es 1:N (Sismografo:CambioEstado) gestionada por una tabla intermedia.&#10;       -------------------------------------------------------------- */&#10;    public List&lt;CambioEstado&gt; findBySismografoId(Connection conn, long idSismografo) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT ce.* FROM CambioEstado ce&#10;            JOIN Sismografo_CambioEstado ces ON ce.idCambioEstado = ces.idCambioEstado&#10;            WHERE ces.identificadorSismografo = ?&#10;            ORDER BY ce.fechaHoraInicio ASC&#10;            &quot;&quot;&quot;;&#10;        List&lt;CambioEstado&gt; cambios = new ArrayList&lt;&gt;();&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idSismografo);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    // Reutilizamos el mapeador, pasándole la conexión activa&#10;                    cambios.add(mapResultSetToCambioEstado(rs, conn));&#10;                }&#10;            }&#10;        }&#10;        return cambios;&#10;    }&#10;    &#10;    /* --------------------------------------------------------------&#10;       FIND BY EVENTO SISMICO ID – carga todos los cambios de estado para un evento&#10;       -------------------------------------------------------------- */&#10;    public List&lt;CambioEstado&gt; findByEventoSismicoId(Connection conn, long idEventoSismico) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT ce.* FROM CambioEstado ce&#10;            JOIN EventoSismico_CambioEstado ece ON ce.idCambioEstado = ece.idCambioEstado&#10;            WHERE ece.idEventoSismico = ?&#10;            ORDER BY ce.fechaHoraInicio ASC&#10;            &quot;&quot;&quot;;&#10;        List&lt;CambioEstado&gt; cambios = new ArrayList&lt;&gt;();&#10;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idEventoSismico);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    cambios.add(mapResultSetToCambioEstado(rs, conn));&#10;                }&#10;            }&#10;        }&#10;        return cambios;&#10;    }&#10;    &#10;    // ==============================================================&#10;    // MÉTODOS AUXILIARES&#10;    // ==============================================================&#10;&#10;    private CambioEstado mapResultSetToCambioEstado(ResultSet rs, Connection conn) throws SQLException {&#10;        CambioEstado ce = new CambioEstado();&#10;&#10;        ce.setIdCambioEstado(rs.getLong(&quot;idCambioEstado&quot;));&#10;        ce.setFechaHoraInicio(getLocalDateTime(rs, &quot;fechaHoraInicio&quot;));&#10;        ce.setFechaHoraFin(getLocalDateTime(rs, &quot;fechaHoraFin&quot;));&#10;&#10;        // Cargar Estado usando la CLAVE COMPUESTA&#10;        String ambito = rs.getString(&quot;ambitoEstado&quot;);&#10;        String nombreEstado = rs.getString(&quot;nombreEstado&quot;);&#10;        Estado estado = estadoDAO.findByAmbitoAndNombre(ambito, nombreEstado);&#10;        ce.setEstado(estado);&#10;&#10;        // Cargar Empleado&#10;        Long idEmpleado = rs.getObject(&quot;idResponsableInspeccion&quot;, Long.class);&#10;        Empleado empleado = idEmpleado != null ? empleadoDAO.findById(idEmpleado) : null;&#10;        ce.setResponsableInspeccion(empleado);&#10;        &#10;        // Cargar idEventoSismico&#10;        Long idEventoSismico = rs.getObject(&quot;idEventoSismico&quot;, Long.class);&#10;        ce.setIdEventoSismico(idEventoSismico);&#10;&#10;        // Cargar motivos fuera de servicio&#10;        List&lt;MotivoFueraServicio&gt; motivos = findMotivosByCambioEstado(conn, ce.getIdCambioEstado());&#10;        ce.setMotivoFueraServicio(motivos);&#10;&#10;        return ce;&#10;    }&#10;&#10;    private LocalDateTime getLocalDateTime(ResultSet rs, String column) throws SQLException {&#10;        Timestamp ts = rs.getTimestamp(column);&#10;        return ts != null ? ts.toLocalDateTime() : null;&#10;    }&#10;&#10;    // ==============================================================&#10;    // MÉTODOS AUXILIARES PARA RELACIÓN N:N CON MotivoFueraServicio&#10;    // ==============================================================&#10;    &#10;    private void insertMotivos(Connection conn, long idCambioEstado, List&lt;MotivoFueraServicio&gt; motivos) throws SQLException {&#10;        String sql = &quot;INSERT INTO CambioEstado_MotivoFueraServicio (idCambioEstado, idMotivoFueraServicio) VALUES (?, ?)&quot;;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            for (MotivoFueraServicio mfs : motivos) {&#10;                ps.setLong(1, idCambioEstado);&#10;                ps.setLong(2, mfs.getIdMotivoFueraServicio());&#10;                ps.addBatch();&#10;            }&#10;            ps.executeBatch();&#10;        }&#10;    }&#10;&#10;    private void deleteMotivos(Connection conn, long idCambioEstado) throws SQLException {&#10;        String sql = &quot;DELETE FROM CambioEstado_MotivoFueraServicio WHERE idCambioEstado = ?&quot;;&#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idCambioEstado);&#10;            ps.executeUpdate();&#10;        }&#10;    }&#10;    &#10;    private List&lt;MotivoFueraServicio&gt; findMotivosByCambioEstado(Connection conn, long idCambioEstado) throws SQLException {&#10;        String sql = &quot;&quot;&quot;&#10;            SELECT mfs.idMotivoFueraServicio FROM MotivoFueraServicio mfs&#10;            JOIN CambioEstado_MotivoFueraServicio cemfs ON mfs.idMotivoFueraServicio = cemfs.idMotivoFueraServicio&#10;            WHERE cemfs.idCambioEstado = ?&#10;            &quot;&quot;&quot;;&#10;        List&lt;MotivoFueraServicio&gt; motivos = new ArrayList&lt;&gt;();&#10;        &#10;        try (PreparedStatement ps = conn.prepareStatement(sql)) {&#10;            ps.setLong(1, idCambioEstado);&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                while (rs.next()) {&#10;                    long idMotivo = rs.getLong(&quot;idMotivoFueraServicio&quot;);&#10;                    MotivoFueraServicio mfs = motivoFueraServicioDAO.findById(idMotivo); &#10;                    if (mfs != null) {&#10;                        motivos.add(mfs);&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return motivos;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>