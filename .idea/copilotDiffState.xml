<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java" />
              <option name="updatedContent" value="package com.ppai.sismos;&#10;&#10;import com.ppai.sismos.controlador.SismoController;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.staticfiles.Location;&#10;&#10;/**&#10; * Clase principal que inicia el servidor HTTP&#10; */&#10;public class Main {&#10;    &#10;    private static final int PORT = 8080;&#10;    &#10;    public static void main(String[] args) {&#10;        // Crear el servidor Javalin&#10;        Javalin app = Javalin.create(config -&gt; {&#10;            // Configurar CORS para permitir conexiones desde el frontend de escritorio&#10;            config.plugins.enableCors(cors -&gt; {&#10;                cors.add(it -&gt; {&#10;                    it.anyHost(); // Permite cualquier origen&#10;                    it.allowCredentials = false;&#10;                });&#10;            });&#10;            &#10;            // Configurar logging&#10;            config.requestLogger.http((ctx, ms) -&gt; {&#10;                System.out.println(ctx.method() + &quot; &quot; + ctx.path() + &quot; - &quot; + ctx.status() + &quot; (&quot; + ms + &quot;ms)&quot;);&#10;            });&#10;        });&#10;        &#10;        // Registrar rutas del controlador&#10;        SismoController sismoController = new SismoController();&#10;        sismoController.registrarRutas(app);&#10;        &#10;        // Ruta de health check&#10;        app.get(&quot;/&quot;, ctx -&gt; ctx.result(&quot;API de Sismos - Backend funcionando correctamente&quot;));&#10;        &#10;        app.get(&quot;/health&quot;, ctx -&gt; ctx.json(java.util.Map.of(&#10;                &quot;status&quot;, &quot;UP&quot;,&#10;                &quot;timestamp&quot;, java.time.LocalDateTime.now().toString()&#10;        )));&#10;        &#10;        // Iniciar el servidor&#10;        app.start(PORT);&#10;        &#10;        System.out.println(&quot;╔═══════════════════════════════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║   Backend de Sistema de Sismos - Iniciado            ║&quot;);&#10;        System.out.println(&quot;║   Puerto: &quot; + PORT + &quot;                                       ║&quot;);&#10;        System.out.println(&quot;║   URL: http://localhost:&quot; + PORT + &quot;                       ║&quot;);&#10;        System.out.println(&quot;║   CORS: Habilitado                                    ║&quot;);&#10;        System.out.println(&quot;║   Base de datos: SQLite (sismos.db)                   ║&quot;);&#10;        System.out.println(&quot;╚═══════════════════════════════════════════════════════╝&quot;);&#10;        System.out.println(&quot;\nPresiona Ctrl+C para detener el servidor\n&quot;);&#10;        &#10;        // Hook para cerrar la base de datos al detener el servidor&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;\nCerrando servidor...&quot;);&#10;            app.stop();&#10;            com.ppai.sismos.datos.DatabaseConnection.getInstance().close();&#10;            System.out.println(&quot;Servidor cerrado correctamente&quot;);&#10;        }));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java" />
              <option name="updatedContent" value="package com.ppai.sismos.controlador;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.GsonBuilder;&#10;import com.google.gson.JsonDeserializer;&#10;import com.google.gson.JsonPrimitive;&#10;import com.google.gson.JsonSerializer;&#10;import com.ppai.sismos.entidad.Sismo;&#10;import com.ppai.sismos.gestor.GestorSismos;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.Context;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Controlador REST que expone los endpoints de la API&#10; * y delega las operaciones al Gestor&#10; */&#10;public class SismoController {&#10;    &#10;    private final GestorSismos gestor;&#10;    private final Gson gson;&#10;    &#10;    public SismoController() {&#10;        this.gestor = GestorSismos.getInstance();&#10;        &#10;        // Configurar Gson para manejar LocalDateTime&#10;        GsonBuilder gsonBuilder = new GsonBuilder();&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonSerializer&lt;LocalDateTime&gt;) (src, typeOfSrc, context) -&gt;&#10;                        new JsonPrimitive(src.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)));&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonDeserializer&lt;LocalDateTime&gt;) (json, typeOfT, context) -&gt;&#10;                        LocalDateTime.parse(json.getAsString(), DateTimeFormatter.ISO_LOCAL_DATE_TIME));&#10;        this.gson = gsonBuilder.create();&#10;    }&#10;    &#10;    public void registrarRutas(Javalin app) {&#10;        // Obtener todos los sismos&#10;        app.get(&quot;/api/sismos&quot;, this::obtenerTodos);&#10;        &#10;        // Obtener un sismo por ID&#10;        app.get(&quot;/api/sismos/{id}&quot;, this::obtenerPorId);&#10;        &#10;        // Crear un nuevo sismo&#10;        app.post(&quot;/api/sismos&quot;, this::crear);&#10;        &#10;        // Actualizar un sismo&#10;        app.put(&quot;/api/sismos/{id}&quot;, this::actualizar);&#10;        &#10;        // Eliminar un sismo&#10;        app.delete(&quot;/api/sismos/{id}&quot;, this::eliminar);&#10;        &#10;        // Buscar por magnitud&#10;        app.get(&quot;/api/sismos/buscar/magnitud/{magnitud}&quot;, this::buscarPorMagnitud);&#10;        &#10;        // Buscar por ubicación&#10;        app.get(&quot;/api/sismos/buscar/ubicacion/{ubicacion}&quot;, this::buscarPorUbicacion);&#10;        &#10;        // Obtener estadísticas&#10;        app.get(&quot;/api/sismos/estadisticas&quot;, this::obtenerEstadisticas);&#10;    }&#10;    &#10;    private void obtenerTodos(Context ctx) {&#10;        try {&#10;            List&lt;Sismo&gt; sismos = gestor.obtenerTodosLosSismos();&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerPorId(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Optional&lt;Sismo&gt; sismo = gestor.buscarSismoPorId(id);&#10;            &#10;            if (sismo.isPresent()) {&#10;                ctx.json(sismo.get());&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void crear(Context ctx) {&#10;        try {&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo nuevoSismo = gestor.registrarNuevoSismo(&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.status(201).json(nuevoSismo);&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void actualizar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo sismoActualizado = gestor.actualizarSismo(&#10;                    id,&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.json(sismoActualizado);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void eliminar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            &#10;            boolean eliminado = gestor.eliminarSismo(id);&#10;            &#10;            if (eliminado) {&#10;                ctx.status(204);&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorMagnitud(Context ctx) {&#10;        try {&#10;            Double magnitud = Double.parseDouble(ctx.pathParam(&quot;magnitud&quot;));&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorMagnitudMinima(magnitud);&#10;            ctx.json(sismos);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;Magnitud inválida&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorUbicacion(Context ctx) {&#10;        try {&#10;            String ubicacion = ctx.pathParam(&quot;ubicacion&quot;);&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorUbicacion(ubicacion);&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerEstadisticas(Context ctx) {&#10;        try {&#10;            GestorSismos.EstadisticasSismos estadisticas = gestor.calcularEstadisticas();&#10;            ctx.json(estadisticas);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java" />
              <option name="updatedContent" value="package com.ppai.sismos.datos;&#10;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class SismoDAO {&#10;    &#10;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;&#10;    private final DatabaseConnection dbConnection;&#10;    &#10;    public SismoDAO() {&#10;        this.dbConnection = DatabaseConnection.getInstance();&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; obtenerTodos() {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (Statement stmt = dbConnection.getConnection().createStatement();&#10;             ResultSet rs = stmt.executeQuery(sql)) {&#10;            &#10;            while (rs.next()) {&#10;                sismos.add(mapResultSetToSismo(rs));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismos&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public Optional&lt;Sismo&gt; obtenerPorId(Long id) {&#10;        String sql = &quot;SELECT * FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismo por ID&quot;, e);&#10;        }&#10;        &#10;        return Optional.empty();&#10;    }&#10;    &#10;    public Sismo guardar(Sismo sismo) {&#10;        String sql = &quot;INSERT INTO sismos (ubicacion, magnitud, profundidad, fecha_hora, descripcion) VALUES (?, ?, ?, ?, ?)&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se pudo crear el sismo&quot;);&#10;            }&#10;            &#10;            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    sismo.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al guardar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public Sismo actualizar(Sismo sismo) {&#10;        String sql = &quot;UPDATE sismos SET ubicacion = ?, magnitud = ?, profundidad = ?, fecha_hora = ?, descripcion = ? WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            pstmt.setLong(6, sismo.getId());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se encontró el sismo con ID: &quot; + sismo.getId());&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al actualizar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public boolean eliminar(Long id) {&#10;        String sql = &quot;DELETE FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            return affectedRows &gt; 0;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al eliminar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorMagnitud(Double magnitudMinima) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE magnitud &gt;= ? ORDER BY magnitud DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setDouble(1, magnitudMinima);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por magnitud&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorUbicacion(String ubicacion) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE LOWER(ubicacion) LIKE LOWER(?) ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, &quot;%&quot; + ubicacion + &quot;%&quot;);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por ubicación&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    private Sismo mapResultSetToSismo(ResultSet rs) throws SQLException {&#10;        Long id = rs.getLong(&quot;id&quot;);&#10;        String ubicacion = rs.getString(&quot;ubicacion&quot;);&#10;        Double magnitud = rs.getDouble(&quot;magnitud&quot;);&#10;        Double profundidad = rs.getDouble(&quot;profundidad&quot;);&#10;        LocalDateTime fechaHora = LocalDateTime.parse(rs.getString(&quot;fecha_hora&quot;), FORMATTER);&#10;        String descripcion = rs.getString(&quot;descripcion&quot;);&#10;        &#10;        return new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java" />
              <option name="updatedContent" value="package com.ppai.sismos.gestor;&#10;&#10;import com.ppai.sismos.datos.SismoDAO;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Gestor que maneja las colaboraciones entre objetos del sistema.&#10; * Esta clase centraliza la lógica de negocio y coordina las operaciones&#10; * entre las entidades y el acceso a datos.&#10; */&#10;public class GestorSismos {&#10;    &#10;    private static GestorSismos instance;&#10;    private final SismoDAO sismoDAO;&#10;    &#10;    private GestorSismos() {&#10;        this.sismoDAO = new SismoDAO();&#10;    }&#10;    &#10;    public static GestorSismos getInstance() {&#10;        if (instance == null) {&#10;            synchronized (GestorSismos.class) {&#10;                if (instance == null) {&#10;                    instance = new GestorSismos();&#10;                }&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;    &#10;    /**&#10;     * Obtiene todos los sismos registrados&#10;     */&#10;    public List&lt;Sismo&gt; obtenerTodosLosSismos() {&#10;        return sismoDAO.obtenerTodos();&#10;    }&#10;    &#10;    /**&#10;     * Busca un sismo por su ID&#10;     */&#10;    public Optional&lt;Sismo&gt; buscarSismoPorId(Long id) {&#10;        return sismoDAO.obtenerPorId(id);&#10;    }&#10;    &#10;    /**&#10;     * Registra un nuevo sismo en el sistema&#10;     * Valida los datos antes de guardar&#10;     */&#10;    public Sismo registrarNuevoSismo(String ubicacion, Double magnitud, Double profundidad, &#10;                                     LocalDateTime fechaHora, String descripcion) {&#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear la entidad&#10;        Sismo nuevoSismo = new Sismo(ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Guardar en la base de datos&#10;        return sismoDAO.guardar(nuevoSismo);&#10;    }&#10;    &#10;    /**&#10;     * Actualiza un sismo existente&#10;     */&#10;    public Sismo actualizarSismo(Long id, String ubicacion, Double magnitud, Double profundidad,&#10;                                 LocalDateTime fechaHora, String descripcion) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear entidad actualizada&#10;        Sismo sismoActualizado = new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Actualizar en la base de datos&#10;        return sismoDAO.actualizar(sismoActualizado);&#10;    }&#10;    &#10;    /**&#10;     * Elimina un sismo del sistema&#10;     */&#10;    public boolean eliminarSismo(Long id) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        return sismoDAO.eliminar(id);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos con magnitud mayor o igual a la especificada&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorMagnitudMinima(Double magnitudMinima) {&#10;        if (magnitudMinima &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser negativa&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorMagnitud(magnitudMinima);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos por ubicación (búsqueda parcial)&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorUbicacion(String ubicacion) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación no puede estar vacía&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorUbicacion(ubicacion);&#10;    }&#10;    &#10;    /**&#10;     * Obtiene sismos recientes (últimos registrados)&#10;     */&#10;    public List&lt;Sismo&gt; obtenerSismosRecientes(int cantidad) {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.size() &lt;= cantidad) {&#10;            return todosLosSismos;&#10;        }&#10;        &#10;        return todosLosSismos.subList(0, cantidad);&#10;    }&#10;    &#10;    /**&#10;     * Calcula estadísticas de los sismos&#10;     */&#10;    public EstadisticasSismos calcularEstadisticas() {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.isEmpty()) {&#10;            return new EstadisticasSismos(0, 0.0, 0.0, 0.0);&#10;        }&#10;        &#10;        double magnitudMaxima = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .max()&#10;                .orElse(0.0);&#10;        &#10;        double magnitudPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        double profundidadPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getProfundidad)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        return new EstadisticasSismos(&#10;                todosLosSismos.size(),&#10;                magnitudMaxima,&#10;                magnitudPromedio,&#10;                profundidadPromedio&#10;        );&#10;    }&#10;    &#10;    // Validaciones privadas&#10;    private void validarDatosSismo(String ubicacion, Double magnitud, Double profundidad, LocalDateTime fechaHora) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación es obligatoria&quot;);&#10;        }&#10;        &#10;        if (magnitud == null || magnitud &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (magnitud &gt; 10) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser mayor a 10&quot;);&#10;        }&#10;        &#10;        if (profundidad == null || profundidad &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La profundidad debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (fechaHora == null) {&#10;            throw new IllegalArgumentException(&quot;La fecha y hora son obligatorias&quot;);&#10;        }&#10;        &#10;        if (fechaHora.isAfter(LocalDateTime.now())) {&#10;            throw new IllegalArgumentException(&quot;La fecha no puede ser futura&quot;);&#10;        }&#10;    }&#10;    &#10;    // Clase interna para estadísticas&#10;    public static class EstadisticasSismos {&#10;        private final int totalSismos;&#10;        private final double magnitudMaxima;&#10;        private final double magnitudPromedio;&#10;        private final double profundidadPromedio;&#10;        &#10;        public EstadisticasSismos(int totalSismos, double magnitudMaxima, &#10;                                 double magnitudPromedio, double profundidadPromedio) {&#10;            this.totalSismos = totalSismos;&#10;            this.magnitudMaxima = magnitudMaxima;&#10;            this.magnitudPromedio = magnitudPromedio;&#10;            this.profundidadPromedio = profundidadPromedio;&#10;        }&#10;        &#10;        public int getTotalSismos() { return totalSismos; }&#10;        public double getMagnitudMaxima() { return magnitudMaxima; }&#10;        public double getMagnitudPromedio() { return magnitudPromedio; }&#10;        public double getProfundidadPromedio() { return profundidadPromedio; }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>