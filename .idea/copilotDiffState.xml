<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/pom.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&#10;         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.ppai&lt;/groupId&gt;&#10;    &lt;artifactId&gt;sismos-backend&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;name&gt;PPAI Sismos Backend&lt;/name&gt;&#10;    &lt;description&gt;Backend para sistema de sismos con Javalin y SQLite&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Javalin - Servidor HTTP ligero --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.javalin&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javalin&lt;/artifactId&gt;&#10;            &lt;version&gt;5.6.3&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- SLF4J - Logging requerido por Javalin --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;&#10;            &lt;version&gt;2.0.9&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Gson para manejo de JSON --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;&#10;            &lt;artifactId&gt;gson&lt;/artifactId&gt;&#10;            &lt;version&gt;2.10.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- SQLite JDBC Driver --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;3.43.0.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;mainClass&gt;com.ppai.app.Main&lt;/mainClass&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&#10;         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.ppai&lt;/groupId&gt;&#10;    &lt;artifactId&gt;sismos-backend&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;name&gt;PPAI Sismos Backend&lt;/name&gt;&#10;    &lt;description&gt;Backend para sistema de sismos con Javalin y SQLite&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Javalin - Servidor HTTP ligero --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;io.javalin&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javalin&lt;/artifactId&gt;&#10;            &lt;version&gt;5.6.3&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- SLF4J - Logging requerido por Javalin --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;&#10;            &lt;version&gt;2.0.9&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Gson para manejo de JSON --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;&#10;            &lt;artifactId&gt;gson&lt;/artifactId&gt;&#10;            &lt;version&gt;2.10.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- SQLite JDBC Driver --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.xerial&lt;/groupId&gt;&#10;            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;&#10;            &lt;version&gt;3.43.0.0&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;mainClass&gt;com.ppai.app.Main&lt;/mainClass&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/Main.java" />
              <option name="updatedContent" value="package com.ppai.app;&#10;&#10;import com.ppai.app.controlador.ControladorEjemplo;&#10;import io.javalin.Javalin;&#10;import io.javalin.plugin.bundled.CorsPluginConfig;&#10;&#10;/**&#10; * Clase principal que inicia el servidor HTTP del backend.&#10; * Aquí puedes configurar tu aplicación según el patrón arquitectónico que necesites implementar.&#10; */&#10;public class Main {&#10;&#10;    private static final int PORT = 8080;&#10;&#10;    public static void main(String[] args) {&#10;        // Crear el servidor Javalin&#10;        Javalin app = Javalin.create(config -&gt; {&#10;            // Configurar CORS para permitir conexiones desde el frontend de escritorio&#10;            config.plugins.enableCors(cors -&gt; {&#10;                cors.add(CorsPluginConfig::anyHost);&#10;            });&#10;            &#10;            // Configurar logging&#10;            config.http.asyncTimeout = 10_000L;&#10;        });&#10;        &#10;        // Registrar el controlador de ejemplo (puedes comentar o eliminar después)&#10;        ControladorEjemplo controladorEjemplo = new ControladorEjemplo();&#10;        controladorEjemplo.registrarRutas(app);&#10;        &#10;        // TODO: Registrar aquí tus controladores y rutas&#10;        // Ejemplo:&#10;        // MiControlador controlador = new MiControlador();&#10;        // controlador.registrarRutas(app);&#10;        &#10;        // Ruta de health check&#10;        app.get(&quot;/&quot;, ctx -&gt; ctx.result(&quot;Backend funcionando correctamente&quot;));&#10;        &#10;        app.get(&quot;/health&quot;, ctx -&gt; ctx.json(java.util.Map.of(&#10;                &quot;status&quot;, &quot;UP&quot;,&#10;                &quot;timestamp&quot;, java.time.LocalDateTime.now().toString()&#10;        )));&#10;        &#10;        // Iniciar el servidor&#10;        app.start(PORT);&#10;        &#10;        System.out.println(&quot;╔═══════════════════════════════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║   Backend - Servidor Iniciado                        ║&quot;);&#10;        System.out.println(&quot;║   Puerto: &quot; + PORT + &quot;                                       ║&quot;);&#10;        System.out.println(&quot;║   URL: http://localhost:&quot; + PORT + &quot;                       ║&quot;);&#10;        System.out.println(&quot;║   CORS: Habilitado                                    ║&quot;);&#10;        System.out.println(&quot;╚═══════════════════════════════════════════════════════╝&quot;);&#10;        System.out.println(&quot;\nPuedes probar la API en http://localhost:&quot; + PORT);&#10;        System.out.println(&quot;Presiona Ctrl+C para detener el servidor\n&quot;);&#10;        &#10;        // Hook para cerrar recursos al detener el servidor&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;\nCerrando servidor...&quot;);&#10;            app.stop();&#10;            // TODO: Cerrar aquí tus conexiones de base de datos si las usas&#10;            System.out.println(&quot;Servidor cerrado correctamente&quot;);&#10;        }));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/controlador/ControladorEjemplo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/controlador/ControladorEjemplo.java" />
              <option name="updatedContent" value="package com.ppai.app.controlador;&#10;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.Context;&#10;import com.google.gson.Gson;&#10;&#10;/**&#10; * Controlador REST de ejemplo.&#10; * Define aquí tus endpoints y la lógica para manejar las peticiones HTTP.&#10; */&#10;public class ControladorEjemplo {&#10;    &#10;    private final Gson gson;&#10;    // TODO: Agregar aquí tu Gestor u otras dependencias&#10;    // Ejemplo: private Gestor gestor;&#10;    &#10;    public ControladorEjemplo() {&#10;        this.gson = new Gson();&#10;        // TODO: Inicializar tu gestor según el patrón que uses&#10;        // Ejemplo: this.gestor = new Gestor();&#10;    }&#10;    &#10;    /**&#10;     * Registra las rutas/endpoints de este controlador&#10;     */&#10;    public void registrarRutas(Javalin app) {&#10;        // Endpoints de ejemplo&#10;        app.get(&quot;/api/ejemplo&quot;, this::obtenerEjemplo);&#10;        app.post(&quot;/api/ejemplo&quot;, this::crearEjemplo);&#10;        &#10;        // TODO: Agrega aquí tus propios endpoints&#10;        // app.get(&quot;/api/entidades&quot;, this::obtenerTodas);&#10;        // app.get(&quot;/api/entidades/{id}&quot;, this::obtenerPorId);&#10;        // app.post(&quot;/api/entidades&quot;, this::crear);&#10;        // app.put(&quot;/api/entidades/{id}&quot;, this::actualizar);&#10;        // app.delete(&quot;/api/entidades/{id}&quot;, this::eliminar);&#10;    }&#10;    &#10;    /**&#10;     * Endpoint GET de ejemplo&#10;     * Prueba con: GET http://localhost:8080/api/ejemplo&#10;     */&#10;    private void obtenerEjemplo(Context ctx) {&#10;        ctx.json(java.util.Map.of(&#10;            &quot;mensaje&quot;, &quot;Este es un endpoint de ejemplo&quot;,&#10;            &quot;info&quot;, &quot;Agrega aquí tu lógica de negocio&quot;,&#10;            &quot;metodo&quot;, &quot;GET&quot;&#10;        ));&#10;    }&#10;    &#10;    /**&#10;     * Endpoint POST de ejemplo&#10;     * Prueba con: POST http://localhost:8080/api/ejemplo&#10;     * Body (JSON): { &quot;dato&quot;: &quot;valor&quot; }&#10;     */&#10;    private void crearEjemplo(Context ctx) {&#10;        // Puedes parsear el body de la petición así:&#10;        // MiEntidad entidad = gson.fromJson(ctx.body(), MiEntidad.class);&#10;        &#10;        ctx.status(201).json(java.util.Map.of(&#10;            &quot;mensaje&quot;, &quot;Recurso creado exitosamente&quot;,&#10;            &quot;id&quot;, 1,&#10;            &quot;metodo&quot;, &quot;POST&quot;&#10;        ));&#10;    }&#10;    &#10;    // TODO: Implementa aquí tus métodos handler para cada endpoint&#10;    // &#10;    // Ejemplo de endpoint que retorna una lista:&#10;    // private void obtenerTodas(Context ctx) {&#10;    //     List&lt;Entidad&gt; entidades = gestor.obtenerTodas();&#10;    //     ctx.json(entidades);&#10;    // }&#10;    //&#10;    // Ejemplo de endpoint con parámetro de ruta:&#10;    // private void obtenerPorId(Context ctx) {&#10;    //     Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;    //     Optional&lt;Entidad&gt; entidad = gestor.obtenerPorId(id);&#10;    //     &#10;    //     if (entidad.isPresent()) {&#10;    //         ctx.json(entidad.get());&#10;    //     } else {&#10;    //         ctx.status(404).json(Map.of(&quot;error&quot;, &quot;No encontrado&quot;));&#10;    //     }&#10;    // }&#10;    //&#10;    // Ejemplo de endpoint POST que recibe datos:&#10;    // private void crear(Context ctx) {&#10;    //     try {&#10;    //         Entidad entidad = gson.fromJson(ctx.body(), Entidad.class);&#10;    //         Entidad nuevaEntidad = gestor.crear(entidad);&#10;    //         ctx.status(201).json(nuevaEntidad);&#10;    //     } catch (Exception e) {&#10;    //         ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;    //     }&#10;    // }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/datos/DatabaseConnection.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/datos/DatabaseConnection.java" />
              <option name="updatedContent" value="package com.ppai.app.datos;&#10;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;&#10;/**&#10; * Clase para gestionar la conexión a la base de datos SQLite.&#10; * Puedes modificar esta clase según tu patrón arquitectónico.&#10; */&#10;public class DatabaseConnection {&#10;    &#10;    private static final String DB_URL = &quot;jdbc:sqlite:database.db&quot;;&#10;    private Connection connection;&#10;    &#10;    public DatabaseConnection() {&#10;        try {&#10;            Class.forName(&quot;org.sqlite.JDBC&quot;);&#10;            this.connection = DriverManager.getConnection(DB_URL);&#10;        } catch (ClassNotFoundException | SQLException e) {&#10;            throw new RuntimeException(&quot;Error al conectar con la base de datos&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public Connection getConnection() {&#10;        try {&#10;            if (connection == null || connection.isClosed()) {&#10;                connection = DriverManager.getConnection(DB_URL);&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener conexión&quot;, e);&#10;        }&#10;        return connection;&#10;    }&#10;    &#10;    public void close() {&#10;        try {&#10;            if (connection != null &amp;&amp; !connection.isClosed()) {&#10;                connection.close();&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/entidad/EntidadEjemplo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/entidad/EntidadEjemplo.java" />
              <option name="updatedContent" value="package com.ppai.app.entidad;&#10;&#10;/**&#10; * Clase base de ejemplo para tus entidades de dominio.&#10; * Elimina esta clase y crea las entidades que necesites para tu proyecto.&#10; */&#10;public class EntidadEjemplo {&#10;    &#10;    private Long id;&#10;    private String nombre;&#10;    &#10;    public EntidadEjemplo() {&#10;    }&#10;    &#10;    public EntidadEjemplo(Long id, String nombre) {&#10;        this.id = id;&#10;        this.nombre = nombre;&#10;    }&#10;    &#10;    // Getters y Setters&#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;    &#10;    public String getNombre() {&#10;        return nombre;&#10;    }&#10;    &#10;    public void setNombre(String nombre) {&#10;        this.nombre = nombre;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/gestor/Gestor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/app/gestor/Gestor.java" />
              <option name="updatedContent" value="package com.ppai.app.gestor;&#10;&#10;/**&#10; * Clase Gestor base (SIN patrón Singleton).&#10; * &#10; * Implementa aquí tu lógica de negocio y colaboraciones entre objetos&#10; * según el patrón arquitectónico que te pidan en el trabajo práctico.&#10; * &#10; * NOTA: Esta clase NO es Singleton, puedes instanciarla como necesites&#10; * según tu patrón arquitectónico específico.&#10; */&#10;public class Gestor {&#10;    &#10;    // TODO: Agregar aquí tus dependencias (DAOs, otras clases, etc.)&#10;    // Ejemplo:&#10;    // private MiDAO dao;&#10;    &#10;    /**&#10;     * Constructor público - NO es Singleton.&#10;     * Puedes recibir dependencias por parámetro si lo necesitas.&#10;     */&#10;    public Gestor() {&#10;        // TODO: Inicializar tus dependencias&#10;    }&#10;    &#10;    // TODO: Implementa aquí tus métodos de lógica de negocio&#10;    // Ejemplo:&#10;    // public List&lt;Entidad&gt; obtenerTodos() { ... }&#10;    // public Entidad crear(Entidad entidad) { ... }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/Main.java" />
              <option name="updatedContent" value="package com.ppai.sismos;&#10;&#10;import com.ppai.sismos.controlador.SismoController;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.staticfiles.Location;&#10;&#10;/**&#10; * Clase principal que inicia el servidor HTTP&#10; */&#10;public class Main {&#10;    &#10;    private static final int PORT = 8080;&#10;    &#10;    public static void main(String[] args) {&#10;        // Crear el servidor Javalin&#10;        Javalin app = Javalin.create(config -&gt; {&#10;            // Configurar CORS para permitir conexiones desde el frontend de escritorio&#10;            config.plugins.enableCors(cors -&gt; {&#10;                cors.add(it -&gt; {&#10;                    it.anyHost(); // Permite cualquier origen&#10;                    it.allowCredentials = false;&#10;                });&#10;            });&#10;            &#10;            // Configurar logging&#10;            config.requestLogger.http((ctx, ms) -&gt; {&#10;                System.out.println(ctx.method() + &quot; &quot; + ctx.path() + &quot; - &quot; + ctx.status() + &quot; (&quot; + ms + &quot;ms)&quot;);&#10;            });&#10;        });&#10;        &#10;        // Registrar rutas del controlador&#10;        SismoController sismoController = new SismoController();&#10;        sismoController.registrarRutas(app);&#10;        &#10;        // Ruta de health check&#10;        app.get(&quot;/&quot;, ctx -&gt; ctx.result(&quot;API de Sismos - Backend funcionando correctamente&quot;));&#10;        &#10;        app.get(&quot;/health&quot;, ctx -&gt; ctx.json(java.util.Map.of(&#10;                &quot;status&quot;, &quot;UP&quot;,&#10;                &quot;timestamp&quot;, java.time.LocalDateTime.now().toString()&#10;        )));&#10;        &#10;        // Iniciar el servidor&#10;        app.start(PORT);&#10;        &#10;        System.out.println(&quot;╔═══════════════════════════════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║   Backend de Sistema de Sismos - Iniciado            ║&quot;);&#10;        System.out.println(&quot;║   Puerto: &quot; + PORT + &quot;                                       ║&quot;);&#10;        System.out.println(&quot;║   URL: http://localhost:&quot; + PORT + &quot;                       ║&quot;);&#10;        System.out.println(&quot;║   CORS: Habilitado                                    ║&quot;);&#10;        System.out.println(&quot;║   Base de datos: SQLite (sismos.db)                   ║&quot;);&#10;        System.out.println(&quot;╚═══════════════════════════════════════════════════════╝&quot;);&#10;        System.out.println(&quot;\nPresiona Ctrl+C para detener el servidor\n&quot;);&#10;        &#10;        // Hook para cerrar la base de datos al detener el servidor&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;\nCerrando servidor...&quot;);&#10;            app.stop();&#10;            com.ppai.sismos.datos.DatabaseConnection.getInstance().close();&#10;            System.out.println(&quot;Servidor cerrado correctamente&quot;);&#10;        }));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/controlador/SismoController.java" />
              <option name="updatedContent" value="package com.ppai.sismos.controlador;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.GsonBuilder;&#10;import com.google.gson.JsonDeserializer;&#10;import com.google.gson.JsonPrimitive;&#10;import com.google.gson.JsonSerializer;&#10;import com.ppai.sismos.entidad.Sismo;&#10;import com.ppai.sismos.gestor.GestorSismos;&#10;import io.javalin.Javalin;&#10;import io.javalin.http.Context;&#10;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Controlador REST que expone los endpoints de la API&#10; * y delega las operaciones al Gestor&#10; */&#10;public class SismoController {&#10;    &#10;    private final GestorSismos gestor;&#10;    private final Gson gson;&#10;    &#10;    public SismoController() {&#10;        this.gestor = GestorSismos.getInstance();&#10;        &#10;        // Configurar Gson para manejar LocalDateTime&#10;        GsonBuilder gsonBuilder = new GsonBuilder();&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonSerializer&lt;LocalDateTime&gt;) (src, typeOfSrc, context) -&gt;&#10;                        new JsonPrimitive(src.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)));&#10;        gsonBuilder.registerTypeAdapter(LocalDateTime.class,&#10;                (JsonDeserializer&lt;LocalDateTime&gt;) (json, typeOfT, context) -&gt;&#10;                        LocalDateTime.parse(json.getAsString(), DateTimeFormatter.ISO_LOCAL_DATE_TIME));&#10;        this.gson = gsonBuilder.create();&#10;    }&#10;    &#10;    public void registrarRutas(Javalin app) {&#10;        // Obtener todos los sismos&#10;        app.get(&quot;/api/sismos&quot;, this::obtenerTodos);&#10;        &#10;        // Obtener un sismo por ID&#10;        app.get(&quot;/api/sismos/{id}&quot;, this::obtenerPorId);&#10;        &#10;        // Crear un nuevo sismo&#10;        app.post(&quot;/api/sismos&quot;, this::crear);&#10;        &#10;        // Actualizar un sismo&#10;        app.put(&quot;/api/sismos/{id}&quot;, this::actualizar);&#10;        &#10;        // Eliminar un sismo&#10;        app.delete(&quot;/api/sismos/{id}&quot;, this::eliminar);&#10;        &#10;        // Buscar por magnitud&#10;        app.get(&quot;/api/sismos/buscar/magnitud/{magnitud}&quot;, this::buscarPorMagnitud);&#10;        &#10;        // Buscar por ubicación&#10;        app.get(&quot;/api/sismos/buscar/ubicacion/{ubicacion}&quot;, this::buscarPorUbicacion);&#10;        &#10;        // Obtener estadísticas&#10;        app.get(&quot;/api/sismos/estadisticas&quot;, this::obtenerEstadisticas);&#10;    }&#10;    &#10;    private void obtenerTodos(Context ctx) {&#10;        try {&#10;            List&lt;Sismo&gt; sismos = gestor.obtenerTodosLosSismos();&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerPorId(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Optional&lt;Sismo&gt; sismo = gestor.buscarSismoPorId(id);&#10;            &#10;            if (sismo.isPresent()) {&#10;                ctx.json(sismo.get());&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void crear(Context ctx) {&#10;        try {&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo nuevoSismo = gestor.registrarNuevoSismo(&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.status(201).json(nuevoSismo);&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void actualizar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            Sismo sismo = gson.fromJson(ctx.body(), Sismo.class);&#10;            &#10;            // Delegar al gestor&#10;            Sismo sismoActualizado = gestor.actualizarSismo(&#10;                    id,&#10;                    sismo.getUbicacion(),&#10;                    sismo.getMagnitud(),&#10;                    sismo.getProfundidad(),&#10;                    sismo.getFechaHora(),&#10;                    sismo.getDescripcion()&#10;            );&#10;            &#10;            ctx.json(sismoActualizado);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void eliminar(Context ctx) {&#10;        try {&#10;            Long id = Long.parseLong(ctx.pathParam(&quot;id&quot;));&#10;            &#10;            boolean eliminado = gestor.eliminarSismo(id);&#10;            &#10;            if (eliminado) {&#10;                ctx.status(204);&#10;            } else {&#10;                ctx.status(404).json(Map.of(&quot;error&quot;, &quot;Sismo no encontrado&quot;));&#10;            }&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;ID inválido&quot;));&#10;        } catch (IllegalArgumentException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorMagnitud(Context ctx) {&#10;        try {&#10;            Double magnitud = Double.parseDouble(ctx.pathParam(&quot;magnitud&quot;));&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorMagnitudMinima(magnitud);&#10;            ctx.json(sismos);&#10;        } catch (NumberFormatException e) {&#10;            ctx.status(400).json(Map.of(&quot;error&quot;, &quot;Magnitud inválida&quot;));&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void buscarPorUbicacion(Context ctx) {&#10;        try {&#10;            String ubicacion = ctx.pathParam(&quot;ubicacion&quot;);&#10;            List&lt;Sismo&gt; sismos = gestor.buscarSismosPorUbicacion(ubicacion);&#10;            ctx.json(sismos);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;    &#10;    private void obtenerEstadisticas(Context ctx) {&#10;        try {&#10;            GestorSismos.EstadisticasSismos estadisticas = gestor.calcularEstadisticas();&#10;            ctx.json(estadisticas);&#10;        } catch (Exception e) {&#10;            ctx.status(500).json(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/datos/SismoDAO.java" />
              <option name="updatedContent" value="package com.ppai.sismos.datos;&#10;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class SismoDAO {&#10;    &#10;    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;&#10;    private final DatabaseConnection dbConnection;&#10;    &#10;    public SismoDAO() {&#10;        this.dbConnection = DatabaseConnection.getInstance();&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; obtenerTodos() {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (Statement stmt = dbConnection.getConnection().createStatement();&#10;             ResultSet rs = stmt.executeQuery(sql)) {&#10;            &#10;            while (rs.next()) {&#10;                sismos.add(mapResultSetToSismo(rs));&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismos&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public Optional&lt;Sismo&gt; obtenerPorId(Long id) {&#10;        String sql = &quot;SELECT * FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al obtener sismo por ID&quot;, e);&#10;        }&#10;        &#10;        return Optional.empty();&#10;    }&#10;    &#10;    public Sismo guardar(Sismo sismo) {&#10;        String sql = &quot;INSERT INTO sismos (ubicacion, magnitud, profundidad, fecha_hora, descripcion) VALUES (?, ?, ?, ?, ?)&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se pudo crear el sismo&quot;);&#10;            }&#10;            &#10;            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    sismo.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al guardar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public Sismo actualizar(Sismo sismo) {&#10;        String sql = &quot;UPDATE sismos SET ubicacion = ?, magnitud = ?, profundidad = ?, fecha_hora = ?, descripcion = ? WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, sismo.getUbicacion());&#10;            pstmt.setDouble(2, sismo.getMagnitud());&#10;            pstmt.setDouble(3, sismo.getProfundidad());&#10;            pstmt.setString(4, sismo.getFechaHora().format(FORMATTER));&#10;            pstmt.setString(5, sismo.getDescripcion());&#10;            pstmt.setLong(6, sismo.getId());&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            &#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;No se encontró el sismo con ID: &quot; + sismo.getId());&#10;            }&#10;            &#10;            return sismo;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al actualizar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public boolean eliminar(Long id) {&#10;        String sql = &quot;DELETE FROM sismos WHERE id = ?&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setLong(1, id);&#10;            &#10;            int affectedRows = pstmt.executeUpdate();&#10;            return affectedRows &gt; 0;&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al eliminar sismo&quot;, e);&#10;        }&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorMagnitud(Double magnitudMinima) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE magnitud &gt;= ? ORDER BY magnitud DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setDouble(1, magnitudMinima);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por magnitud&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    public List&lt;Sismo&gt; buscarPorUbicacion(String ubicacion) {&#10;        List&lt;Sismo&gt; sismos = new ArrayList&lt;&gt;();&#10;        String sql = &quot;SELECT * FROM sismos WHERE LOWER(ubicacion) LIKE LOWER(?) ORDER BY fecha_hora DESC&quot;;&#10;        &#10;        try (PreparedStatement pstmt = dbConnection.getConnection().prepareStatement(sql)) {&#10;            pstmt.setString(1, &quot;%&quot; + ubicacion + &quot;%&quot;);&#10;            &#10;            try (ResultSet rs = pstmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    sismos.add(mapResultSetToSismo(rs));&#10;                }&#10;            }&#10;        } catch (SQLException e) {&#10;            throw new RuntimeException(&quot;Error al buscar sismos por ubicación&quot;, e);&#10;        }&#10;        &#10;        return sismos;&#10;    }&#10;    &#10;    private Sismo mapResultSetToSismo(ResultSet rs) throws SQLException {&#10;        Long id = rs.getLong(&quot;id&quot;);&#10;        String ubicacion = rs.getString(&quot;ubicacion&quot;);&#10;        Double magnitud = rs.getDouble(&quot;magnitud&quot;);&#10;        Double profundidad = rs.getDouble(&quot;profundidad&quot;);&#10;        LocalDateTime fechaHora = LocalDateTime.parse(rs.getString(&quot;fecha_hora&quot;), FORMATTER);&#10;        String descripcion = rs.getString(&quot;descripcion&quot;);&#10;        &#10;        return new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/ppai/sismos/gestor/GestorSismos.java" />
              <option name="updatedContent" value="package com.ppai.sismos.gestor;&#10;&#10;import com.ppai.sismos.datos.SismoDAO;&#10;import com.ppai.sismos.entidad.Sismo;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * Gestor que maneja las colaboraciones entre objetos del sistema.&#10; * Esta clase centraliza la lógica de negocio y coordina las operaciones&#10; * entre las entidades y el acceso a datos.&#10; */&#10;public class GestorSismos {&#10;    &#10;    private static GestorSismos instance;&#10;    private final SismoDAO sismoDAO;&#10;    &#10;    private GestorSismos() {&#10;        this.sismoDAO = new SismoDAO();&#10;    }&#10;    &#10;    public static GestorSismos getInstance() {&#10;        if (instance == null) {&#10;            synchronized (GestorSismos.class) {&#10;                if (instance == null) {&#10;                    instance = new GestorSismos();&#10;                }&#10;            }&#10;        }&#10;        return instance;&#10;    }&#10;    &#10;    /**&#10;     * Obtiene todos los sismos registrados&#10;     */&#10;    public List&lt;Sismo&gt; obtenerTodosLosSismos() {&#10;        return sismoDAO.obtenerTodos();&#10;    }&#10;    &#10;    /**&#10;     * Busca un sismo por su ID&#10;     */&#10;    public Optional&lt;Sismo&gt; buscarSismoPorId(Long id) {&#10;        return sismoDAO.obtenerPorId(id);&#10;    }&#10;    &#10;    /**&#10;     * Registra un nuevo sismo en el sistema&#10;     * Valida los datos antes de guardar&#10;     */&#10;    public Sismo registrarNuevoSismo(String ubicacion, Double magnitud, Double profundidad, &#10;                                     LocalDateTime fechaHora, String descripcion) {&#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear la entidad&#10;        Sismo nuevoSismo = new Sismo(ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Guardar en la base de datos&#10;        return sismoDAO.guardar(nuevoSismo);&#10;    }&#10;    &#10;    /**&#10;     * Actualiza un sismo existente&#10;     */&#10;    public Sismo actualizarSismo(Long id, String ubicacion, Double magnitud, Double profundidad,&#10;                                 LocalDateTime fechaHora, String descripcion) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        // Validaciones de negocio&#10;        validarDatosSismo(ubicacion, magnitud, profundidad, fechaHora);&#10;        &#10;        // Crear entidad actualizada&#10;        Sismo sismoActualizado = new Sismo(id, ubicacion, magnitud, profundidad, fechaHora, descripcion);&#10;        &#10;        // Actualizar en la base de datos&#10;        return sismoDAO.actualizar(sismoActualizado);&#10;    }&#10;    &#10;    /**&#10;     * Elimina un sismo del sistema&#10;     */&#10;    public boolean eliminarSismo(Long id) {&#10;        // Validar que exista el sismo&#10;        Optional&lt;Sismo&gt; sismoExistente = sismoDAO.obtenerPorId(id);&#10;        if (sismoExistente.isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;No existe un sismo con ID: &quot; + id);&#10;        }&#10;        &#10;        return sismoDAO.eliminar(id);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos con magnitud mayor o igual a la especificada&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorMagnitudMinima(Double magnitudMinima) {&#10;        if (magnitudMinima &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser negativa&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorMagnitud(magnitudMinima);&#10;    }&#10;    &#10;    /**&#10;     * Busca sismos por ubicación (búsqueda parcial)&#10;     */&#10;    public List&lt;Sismo&gt; buscarSismosPorUbicacion(String ubicacion) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación no puede estar vacía&quot;);&#10;        }&#10;        &#10;        return sismoDAO.buscarPorUbicacion(ubicacion);&#10;    }&#10;    &#10;    /**&#10;     * Obtiene sismos recientes (últimos registrados)&#10;     */&#10;    public List&lt;Sismo&gt; obtenerSismosRecientes(int cantidad) {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.size() &lt;= cantidad) {&#10;            return todosLosSismos;&#10;        }&#10;        &#10;        return todosLosSismos.subList(0, cantidad);&#10;    }&#10;    &#10;    /**&#10;     * Calcula estadísticas de los sismos&#10;     */&#10;    public EstadisticasSismos calcularEstadisticas() {&#10;        List&lt;Sismo&gt; todosLosSismos = sismoDAO.obtenerTodos();&#10;        &#10;        if (todosLosSismos.isEmpty()) {&#10;            return new EstadisticasSismos(0, 0.0, 0.0, 0.0);&#10;        }&#10;        &#10;        double magnitudMaxima = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .max()&#10;                .orElse(0.0);&#10;        &#10;        double magnitudPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getMagnitud)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        double profundidadPromedio = todosLosSismos.stream()&#10;                .mapToDouble(Sismo::getProfundidad)&#10;                .average()&#10;                .orElse(0.0);&#10;        &#10;        return new EstadisticasSismos(&#10;                todosLosSismos.size(),&#10;                magnitudMaxima,&#10;                magnitudPromedio,&#10;                profundidadPromedio&#10;        );&#10;    }&#10;    &#10;    // Validaciones privadas&#10;    private void validarDatosSismo(String ubicacion, Double magnitud, Double profundidad, LocalDateTime fechaHora) {&#10;        if (ubicacion == null || ubicacion.trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;La ubicación es obligatoria&quot;);&#10;        }&#10;        &#10;        if (magnitud == null || magnitud &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La magnitud debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (magnitud &gt; 10) {&#10;            throw new IllegalArgumentException(&quot;La magnitud no puede ser mayor a 10&quot;);&#10;        }&#10;        &#10;        if (profundidad == null || profundidad &lt; 0) {&#10;            throw new IllegalArgumentException(&quot;La profundidad debe ser un valor positivo&quot;);&#10;        }&#10;        &#10;        if (fechaHora == null) {&#10;            throw new IllegalArgumentException(&quot;La fecha y hora son obligatorias&quot;);&#10;        }&#10;        &#10;        if (fechaHora.isAfter(LocalDateTime.now())) {&#10;            throw new IllegalArgumentException(&quot;La fecha no puede ser futura&quot;);&#10;        }&#10;    }&#10;    &#10;    // Clase interna para estadísticas&#10;    public static class EstadisticasSismos {&#10;        private final int totalSismos;&#10;        private final double magnitudMaxima;&#10;        private final double magnitudPromedio;&#10;        private final double profundidadPromedio;&#10;        &#10;        public EstadisticasSismos(int totalSismos, double magnitudMaxima, &#10;                                 double magnitudPromedio, double profundidadPromedio) {&#10;            this.totalSismos = totalSismos;&#10;            this.magnitudMaxima = magnitudMaxima;&#10;            this.magnitudPromedio = magnitudPromedio;&#10;            this.profundidadPromedio = profundidadPromedio;&#10;        }&#10;        &#10;        public int getTotalSismos() { return totalSismos; }&#10;        public double getMagnitudMaxima() { return magnitudMaxima; }&#10;        public double getMagnitudPromedio() { return magnitudPromedio; }&#10;        public double getProfundidadPromedio() { return profundidadPromedio; }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/pom.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/pom.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&#10;         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.ppai&lt;/groupId&gt;&#10;    &lt;artifactId&gt;sismos-frontend&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0.0&lt;/version&gt;&#10;    &lt;name&gt;PPAI Sismos Frontend&lt;/name&gt;&#10;    &lt;description&gt;Frontend de escritorio para sistema de sismos con JFrame&lt;/description&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;java.version&gt;17&lt;/java.version&gt;&#10;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;!-- Gson para manejar JSON --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;&#10;            &lt;artifactId&gt;gson&lt;/artifactId&gt;&#10;            &lt;version&gt;2.10.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Apache HttpClient para realizar peticiones HTTP al backend --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.httpcomponents.client5&lt;/groupId&gt;&#10;            &lt;artifactId&gt;httpclient5&lt;/artifactId&gt;&#10;            &lt;version&gt;5.2.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.11.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;17&lt;/source&gt;&#10;                    &lt;target&gt;17&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.3.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;archive&gt;&#10;                        &lt;manifest&gt;&#10;                            &lt;mainClass&gt;com.ppai.app.frontend.gui.MainFrame&lt;/mainClass&gt;&#10;                        &lt;/manifest&gt;&#10;                    &lt;/archive&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;!-- Exec plugin for running the MainFrame --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;&#10;                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.6.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;mainClass&gt;com.ppai.app.frontend.gui.MainFrame&lt;/mainClass&gt;&#10;                    &lt;includeProjectDependencies&gt;true&lt;/includeProjectDependencies&gt;&#10;                    &lt;classpathScope&gt;runtime&lt;/classpathScope&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &lt;!-- MAVEN SHADE PLUGIN for jar-with-dependencies --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.2.4&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;&#10;                            &lt;shadedClassifierName&gt;jar-with-dependencies&lt;/shadedClassifierName&gt;&#10;                            &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;mainClass&gt;com.ppai.app.frontend.gui.MainFrame&lt;/mainClass&gt;&#10;                                &lt;/transformer&gt;&#10;                            &lt;/transformers&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/gui/MainFrame.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/gui/MainFrame.java" />
              <option name="updatedContent" value="package com.ppai.app.frontend.gui;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * Ventana principal de la aplicación de escritorio.&#10; * Puedes editar esta clase en NetBeans arrastrando componentes desde la paleta.&#10; */&#10;public class MainFrame extends JFrame {&#10;    &#10;    public MainFrame() {&#10;        initComponents();&#10;    }&#10;    &#10;    private void initComponents() {&#10;        setTitle(&quot;Aplicación PPAI&quot;);&#10;        setSize(800, 600);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLocationRelativeTo(null);&#10;        setLayout(new BorderLayout(10, 10));&#10;        &#10;        // TODO: Agregar aquí tus componentes de interfaz&#10;        // Puedes editarlos visualmente en NetBeans&#10;        &#10;        JLabel labelBienvenida = new JLabel(&quot;Aplicación lista para desarrollar&quot;, SwingConstants.CENTER);&#10;        labelBienvenida.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 24));&#10;        add(labelBienvenida, BorderLayout.CENTER);&#10;    }&#10;    &#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            MainFrame frame = new MainFrame();&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/model/ModeloEjemplo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/model/ModeloEjemplo.java" />
              <option name="updatedContent" value="package com.ppai.app.frontend.model;&#10;&#10;/**&#10; * Modelo de datos de ejemplo para el frontend.&#10; * Crea aquí las clases que representen los datos que manejarás en la interfaz.&#10; */&#10;public class ModeloEjemplo {&#10;    &#10;    private Long id;&#10;    private String nombre;&#10;    &#10;    public ModeloEjemplo() {&#10;    }&#10;    &#10;    public ModeloEjemplo(Long id, String nombre) {&#10;        this.id = id;&#10;        this.nombre = nombre;&#10;    }&#10;    &#10;    public Long getId() {&#10;        return id;&#10;    }&#10;    &#10;    public void setId(Long id) {&#10;        this.id = id;&#10;    }&#10;    &#10;    public String getNombre() {&#10;        return nombre;&#10;    }&#10;    &#10;    public void setNombre(String nombre) {&#10;        this.nombre = nombre;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/service/ApiService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/main/java/com/ppai/app/frontend/service/ApiService.java" />
              <option name="originalContent" value="package com.ppai.app.frontend.gui;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;&#10;/**&#10; * Ventana principal de la aplicación de escritorio.&#10; * Puedes editar esta clase en NetBeans arrastrando componentes desde la paleta.&#10; */&#10;public class MainFrame extends JFrame {&#10;&#10;    public MainFrame() {&#10;        initComponents();&#10;    }&#10;&#10;    private void initComponents() {&#10;        setTitle(&quot;Aplicación PPAI&quot;);&#10;        setSize(800, 600);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLocationRelativeTo(null);&#10;        setLayout(new BorderLayout(10, 10));&#10;&#10;        // TODO: Agregar aquí tus componentes de interfaz&#10;        // Puedes editarlos visualmente en NetBeans&#10;&#10;        JLabel labelBienvenida = new JLabel(&quot;Aplicación lista para desarrollar&quot;, SwingConstants.CENTER);&#10;        labelBienvenida.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 24));&#10;        add(labelBienvenida, BorderLayout.CENTER);&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            MainFrame frame = new MainFrame();&#10;            frame.setVisible(true);&#10;        });&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.ppai.app.frontend.service;&#10;&#10;import com.google.gson.Gson;&#10;import org.apache.hc.client5.http.classic.methods.*;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;&#10;import org.apache.hc.client5.http.impl.classic.HttpClients;&#10;import org.apache.hc.core5.http.io.entity.EntityUtils;&#10;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Servicio para comunicarse con el backend mediante HTTP.&#10; * Puedes crear métodos aquí para hacer peticiones GET, POST, PUT, DELETE, etc.&#10; */&#10;public class ApiService {&#10;&#10;    private static final String BASE_URL = &quot;http://localhost:8080/api&quot;;&#10;    private final Gson gson;&#10;    private final CloseableHttpClient httpClient;&#10;&#10;    public ApiService() {&#10;        this.httpClient = HttpClients.createDefault();&#10;        this.gson = new Gson();&#10;    }&#10;&#10;    // TODO: Implementa aquí tus métodos para comunicarte con el backend&#10;    // Ejemplos:&#10;&#10;    // public List&lt;MiEntidad&gt; obtenerTodas() throws IOException {&#10;    //     HttpGet request = new HttpGet(BASE_URL + &quot;/entidades&quot;);&#10;    //     try (CloseableHttpResponse response = httpClient.execute(request)) {&#10;    //         String json = EntityUtils.toString(response.getEntity());&#10;    //         Type listType = new TypeToken&lt;ArrayList&lt;MiEntidad&gt;&gt;(){}.getType();&#10;    //         return gson.fromJson(json, listType);&#10;    //     }&#10;    // }&#10;&#10;    // public MiEntidad crear(MiEntidad entidad) throws IOException {&#10;    //     HttpPost request = new HttpPost(BASE_URL + &quot;/entidades&quot;);&#10;    //     String json = gson.toJson(entidad);&#10;    //     StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);&#10;    //     request.setEntity(entity);&#10;    //     try (CloseableHttpResponse response = httpClient.execute(request)) {&#10;    //         String responseJson = EntityUtils.toString(response.getEntity());&#10;    //         return gson.fromJson(responseJson, MiEntidad.class);&#10;    //     }&#10;    // }&#10;&#10;    public void cerrar() throws IOException {&#10;        httpClient.close();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run-frontend.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run-frontend.bat" />
              <option name="originalContent" value="@echo off&#10;echo ================================================&#10;echo   Iniciando Frontend - Sistema PPAI&#10;echo ================================================&#10;echo.&#10;echo IMPORTANTE: Asegurate de que el backend este corriendo&#10;echo en http://localhost:8080 antes de usar el frontend&#10;echo.&#10;&#10;cd frontend&#10;&#10;echo Compilando el proyecto...&#10;call mvnw.cmd clean install -DskipTests&#10;&#10;echo.&#10;echo Iniciando la aplicación de escritorio...&#10;echo.&#10;&#10;call mvnw.cmd exec:java -Dexec.mainClass=&quot;com.ppai.app.frontend.gui.MainFrame&quot;&#10;pause&#10;" />
              <option name="updatedContent" value="@echo off&#10;echo ================================================&#10;echo   Iniciando Frontend - Sistema PPAI&#10;echo ===============================================&#10;echo.&#10;echo IMPORTANTE: Asegurate de que el backend este corriendo&#10;echo en http://localhost:8080 antes de usar el frontend&#10;echo.&#10;&#10;cd frontend&#10;&#10;echo Compilando el proyecto...&#10;call mvnw.cmd clean compile -DskipTests&#10;&#10;echo.&#10;echo Copiando dependencias...&#10;call mvnw.cmd dependency:copy-dependencies -DoutputDirectory=target\dependency -DincludeScope=runtime&#10;&#10;echo.&#10;echo Ejecutando la aplicación de escritorio...&#10;java -cp &quot;target\classes;target\dependency\*&quot; com.ppai.app.frontend.gui.MainFrame&#10;&#10;pause" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>